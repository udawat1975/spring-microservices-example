pipeline {
  agent any

  environment {
    APP          = 'product-service'
    REGISTRY     = 'docker.io/udawat'
    IMAGE_REPO   = "${REGISTRY}/${APP}"
  }

  stages {
    stage('Build Application') {
      steps {
        dir('product-service') {
          sh 'chmod +x mvnw'
          sh './mvnw -q clean package -DskipTests'
        }
      }
    }

    stage('Build Docker Image') {
      steps {
        dir('product-service') {
          sh 'docker build -t ${APP}:latest .'
        }
      }
    }

    stage('Tag & Push Image to Docker Hub') {
      steps {
        script {
          env.IMAGE_TAG = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()
        }
        withCredentials([usernamePassword(credentialsId: 'DOCKER_HUB_CREDS', usernameVariable: 'USER', passwordVariable: 'PASS')]) {
          sh '''
            echo "$PASS" | docker login docker.io -u "$USER" --password-stdin
            docker tag ${APP}:latest ${IMAGE_REPO}:${IMAGE_TAG}
            docker tag ${APP}:latest ${IMAGE_REPO}:latest
            docker push ${IMAGE_REPO}:${IMAGE_TAG}
            docker push ${IMAGE_REPO}:latest
          '''
        }
      }
    }

    stage('Deploy to Kubernetes') {
      steps {
        // Use a flattened kubeconfig uploaded as a Secret file credential
        withCredentials([file(credentialsId: 'kubeconfig-file', variable: 'KUBECONFIG')]) {
          dir('product-service') {
            sh '''
              # Try to update image on existing deployment; if it doesn't exist yet, apply manifests first.
              kubectl set image deployment/${APP} ${APP}=${IMAGE_REPO}:${IMAGE_TAG} || kubectl apply -f product-service-deployment.yaml

              # Ensure the deployment now points to the immutable tag (covers first-time apply case)
              kubectl set image deployment/${APP} ${APP}=${IMAGE_REPO}:${IMAGE_TAG} --overwrite

              # Wait for rollout to finish
              kubectl rollout status deployment/${APP}
            '''
          }
        }
      }
    }
  }

  post {
    always {
      sh 'docker image prune -f || true'
    }
  }
}
