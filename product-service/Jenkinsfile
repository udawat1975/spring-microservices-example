pipeline {
  agent any

  environment {
    APP        = 'product-service'
    REGISTRY   = 'docker.io/udawat'
    IMAGE_REPO = "${REGISTRY}/${APP}"
    KUBECONFIG = '/var/lib/jenkins/.kube/config'
  }

  stages {
    stage('Build Application') {
      steps {
        dir('product-service') {
          sh 'chmod +x mvnw'
          sh './mvnw -q clean package -DskipTests'
        }
      }
    }

    stage('Build Docker Image') {
      steps {
        dir('product-service') {
          sh 'docker build -t ${APP}:latest .'
        }
      }
    }

    stage('Tag & Push Image to Docker Hub') {
      steps {
        script {
          env.IMAGE_TAG = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()
        }
        withCredentials([usernamePassword(credentialsId: 'DOCKER_HUB_CREDS', usernameVariable: 'USER', passwordVariable: 'PASS')]) {
          sh '''
            echo "$PASS" | docker login docker.io -u "$USER" --password-stdin
            docker tag ${APP}:latest ${IMAGE_REPO}:${IMAGE_TAG}
            docker tag ${APP}:latest ${IMAGE_REPO}:latest
            docker push ${IMAGE_REPO}:${IMAGE_TAG}
            docker push ${IMAGE_REPO}:latest
          '''
        }
      }
    }

    stage('Deploy to Kubernetes') {
      steps {
        dir('product-service') {
          sh '''
            set -e
            # Ensure resources exist (first run creates them)
            kubectl apply -f product-service-deployment.yaml

            # Update the running deployment to the new immutable tag
            kubectl set image deployment/${APP} ${APP}=${IMAGE_REPO}:${IMAGE_TAG}

            # Wait for rollout to complete
            kubectl rollout status deployment/${APP} --timeout=180s
          '''
        }
      }
    }
  }

  post {
    always {
      sh 'docker image prune -f || true'
    }
  }
}
