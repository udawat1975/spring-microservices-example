pipeline {
  agent any

  environment {
    APP         = 'product-service'
    REGISTRY    = 'docker.io/udawat'
    IMAGE_REPO  = "${REGISTRY}/${APP}"
    // kubeconfig is the flattened file you created & mounted
    KUBECONFIG  = '/var/jenkins_home/.kube/kubeconfig-ci'
  }

  stages {
    stage('Build Application') {
      steps {
        dir('product-service') {
          sh 'chmod +x mvnw'
          sh './mvnw -q clean package -DskipTests'
        }
      }
    }

    stage('Build Docker Image') {
      steps {
        dir('product-service') {
          sh 'docker build -t ${APP}:latest .'
        }
      }
    }

    stage('Tag & Push Image to Docker Hub') {
      steps {
        script {
          env.IMAGE_TAG = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()
        }
        withCredentials([usernamePassword(credentialsId: 'DOCKER_HUB_CREDS', usernameVariable: 'USER', passwordVariable: 'PASS')]) {
          sh '''
            echo "$PASS" | docker login docker.io -u "$USER" --password-stdin
            docker tag ${APP}:latest ${IMAGE_REPO}:${IMAGE_TAG}
            docker tag ${APP}:latest ${IMAGE_REPO}:latest
            docker push ${IMAGE_REPO}:${IMAGE_TAG}
            docker push ${IMAGE_REPO}:latest
          '''
        }
      }
    }

    stage('Deploy to Kubernetes') {
      steps {
        dir('product-service') {
          sh '''
            # Sanity check context
            kubectl config current-context

            # Try updating the image (won't fail the build if it's first deploy)
            kubectl set image deployment/${APP} ${APP}=${IMAGE_REPO}:${IMAGE_TAG} || true

            # Ensure manifests exist (first-time apply or drift)
            kubectl apply -f product-service-deployment.yaml

            # Force deployment to the immutable tag again (covers first apply case)
            kubectl set image deployment/${APP} ${APP}=${IMAGE_REPO}:${IMAGE_TAG} --overwrite

            # Wait for rollout
            kubectl rollout status deployment/${APP} --timeout=180s
          '''
        }
      }
    }
  }

  post {
    always {
      sh 'docker image prune -f || true'
    }
  }
}
